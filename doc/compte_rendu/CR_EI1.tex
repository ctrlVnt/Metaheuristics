% =====================================================================================
% Document : rendu du DM1
% Auteur : Xavier Gandibleux
% Année académique : 2020-2021

\section*{Livrable de l'exercice d'implémentation  1 : \\ Heuristiques de construction et d'amélioration gloutonnes}

%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
      \Large{Formulation du SPP}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
Soit $U = \{1, 2, \ldots, n\}$ l'ensemble universel et une collection d'ensembles $\mathcal{S} = \{S_1, S_2, \ldots, S_m\}$, où $S_j \subseteq U$, chacun ayant un poids associé $c_j \in {R}^{+}$.

L'objectif est de sélectionner un sous-ensemble d'ensembles de $\mathcal{S}$ qui sont mutuellement disjoints et dont la somme des poids est maximale.

\subsection*{Variables de Décision}
$x_j \in \{0, 1\}, \quad \forall j \in \{1, 2, \ldots, m\}$
$$
x_j =
\begin{cases}
1 & \text{si l'ensemble } S_j \text{ est sélectionné} \\
0 & \text{sinon}
\end{cases}
$$

\subsection*{Formulation du Problème}
\begin{align*}
\text{\textbf{Maximiser}} \quad & \sum_{j=1}^{m} c_j \cdot x_j \\
\text{\textbf{Sous les contraintes :}} \\
& \sum_{j: i \in S_j} x_j \leq 1 \quad & \forall i \in U \tag{Contrainte de Disjonction} \\
& x_j \in \{0, 1\} \quad & \forall j \in \{1, 2, \ldots, m\} \tag{Variables Binaires}
\end{align*}

\subsection*{Cas practique : Le Problème de Planification Ferroviaire (RPP)}
\noindent
Le RPP se concentre sur l'optimisation de la construction ou de la reconstruction d'infrastructures ferroviaires. Il s'agit spécifiquement de planifier l'utilisation et la capacité des composants critiques d'un système ferroviaire.

\noindent \textbf{Étant donné :}
\begin{itemize}
    \item Un ensemble fini d'éléments $I = \{1, \ldots, n\}$
    \item $\{T_j\}$, $j \in J = \{1, \ldots, m\}$, une collection de $m$ sous-ensembles de $I$
\end{itemize}
\noindent
Une sélection (ou recouvrement) est un sous-ensemble $P \subseteq I$ tel que $|T_j \cap P| \leq 1, \forall j \in J$, ce qui mène à la formulation :

\begin{equation*}
\label{eq:SPP_Strict}
\begin{aligned}
\textbf{Maximiser} \quad & z(\mathbf{x}) = \sum_{i \in I} c_i x_i \\
\textbf{Sous les contraintes :} \quad & \sum_{i \in I} t_{i,j} x_i \leq 1 \quad & \forall j \in J \\
& x_i \in \{0, 1\} \quad & \forall i \in I \\
& t_{i,j} \in \{0, 1\} \quad & \forall i \in I, \forall j \in J
\end{aligned}
\end{equation*}

\begin{itemize}
    \item Fortement NP-Difficile (Garey and Johnson 1979)
    \item Problème du Recouvrement de Nœuds : $\sum_{i \in I} t_{i,j} = 2, \forall j \in J$
\end{itemize}

%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Modélisation JuMP (ou GMP) du SPP}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
La librairie \textbf{JuMP} est un langage de modélisation mathématique open-source conçu pour le langage \textsc{Julia}. Elle permet aux utilisateurs de formuler des problèmes d'optimisation complexes.
Dans cet exemple, nous avons utilisé l'optimiseur GLPK.

\begin{lstlisting}
C, A = loadSPP(fullpath)

    solverSelected = GLPK.Optimizer
    spp = setSPP(C, A)

    set_optimizer(spp, solverSelected)
     t_start = time()
    optimize!(spp)
    time_jump = time() - t_start
\end{lstlisting}

\noindent
Vous trouverez ci-dessous les résultats de l'expérience.

Result GLPK
\begin{longtable}[c]{| c | c | c |}
\hline
File & GLPK (JuMP) & Time (s) \\
\hline
pb\_1000rnd0100.dat & 67 & 212.380985 \\
pb\_1000rnd0800.dat & NA & +10 min.\\
pb\_100rnd0500.dat & 639 & 0.000267 \\
pb\_100rnd1200.dat & 23 & 0.231301 \\
pb\_2000rnd0400.dat & NA & +10 min.\\    
pb\_2000rnd0500.dat & NA & +10 min.\\
pb\_200rnd0300.dat & NA & +10 min.\\
pb\_200rnd1800.dat & 19 & 174.513032 \\
pb\_500rnd0700.dat & NA & +10 min.\\
pb\_500rnd1700.dat & NA & +10 min.\\
\hline
\end{longtable}

%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Instances numériques de SPP}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
Dans le (Tableau \ref{tab:resultatsei1}) les 10 instances sélectionnées.

  \begin{table}[h!]
        \centering
        \begin{tabular}{|c|l|l|l|l|l|}\hline
 Instance& n° Variables& n° contrantes& Densité (\%)&Max-Uns &Meillere valer connue\\\hline\hline
            pb\_1000rnd0100.dat & 1000& 5000& 2,60& 50&67*\\\hline
            pb\_1000rnd0800.dat & 1000& 1000& 0,60& 10&175*\\\hline
            pb\_100rnd0500.dat & 100& 500& 2& 2&639*\\\hline
            pb\_100rnd1200.dat & 100& 300& 2,97& 4&23*\\\hline
            pb\_2000rnd0400.dat & 2000& 10000& 0,55& 20&32\\ \hline            
            pb\_2000rnd0500.dat & 2000& 2000& 2,55& 100&140\\\hline
            pb\_200rnd0300.dat & 200& 1000& 1& 2&731*\\\hline
            pb\_200rnd1800.dat & 200& 200& 1,50& 4&83*\\\hline
            pb\_500rnd0700.dat & 500& 500& 1,20& 10&1141*\\\hline
            pb\_500rnd1700.dat & 500& 1500& 2,17& 20&192*\\\hline
        \end{tabular}
        \caption{instances sélectionnées}
        \label{tab:resultatsei1}
    \end{table}

%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Heuristique de construction appliquée au SPP}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
L'algorithme glouton a été utilisé pour la construction heuristique.
L’algorithme glouton sélectionne la première colonne admissible, l’ajoute à la solution, puis avance en ne choisissant que des colonnes qui restent compatibles avec celles déjà sélectionnées.
Il construit une solution initiale de manière séquentielle, en ajoutant progressivement des éléments non conflictuels.

\begin{algorithm}[h!]
    \caption{La construction gloutonne}
    \label{alg:greedy_construction}
    \begin{algorithmic}[1] % [1] pour la numérotation des lignes
        \State $S \leftarrow \emptyset$ \Comment{Initialise la solution comme un ensemble vide}
        \State Initialiser l'ensemble des candidats $C$, et évaluer l'utilité $u(e), \forall e \in C$
        \While {($C \neq \emptyset$)}
            \State Sélectionner le meilleur élément courant $e$ de $C$ :
            \State \quad $e \leftarrow \underset{e \in C}{\operatorname{next}} \, u(e)$ \Comment{Choisir l'élément suivante}
            \State Incorporer $e$ dans la solution :
            \State \quad $S \leftarrow S \cup \{e\}$
            \State Mettre à jour l'ensemble des candidats $C$ et réévaluer l'utilité $u(e), \forall e \in C$
            \State \quad $C \leftarrow C \setminus \text{conflict}(\{e\})$ \Comment{Retirer $e$ et tous les éléments en conflit avec $e$}
        \EndWhile
        \State \textbf{retourner} $S$
    \end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item \textit{S}: ensemble des solutions
    \item \textit{C} : solutions candidates
    \item \textit{e} : variable
\end{itemize}

\subsection*{Exemple Didactique de la Construction Gloutonne (Sélection Forcée)}

\noindent
Considérons un problème de sélection d'éléments pour maximiser l'utilité totale, soumis à des contraintes de conflit.

\textbf{Données :}
\begin{itemize}
    \item \textbf{Ensemble initial des candidats $C$ :} $C = \{e_1, e_2, e_3, e_4, e_5, e_6, e_7\}$.
    \item \textbf{Utilités $u(e)$ :}
    \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    Élément & $e_1$ & $e_2$ & $e_3$ & $e_4$ & $e_5$ & $e_6$ & $e_7$ \\
    \hline
    Utilité $u(e)$ & 10 & 5 & 8 & 6 & 9 & 13& 11 \\
    \hline
    \end{tabular}
    \end{center}
\end{itemize}
\textbf{Déroulement de l'algorithme :}

\begin{enumerate}
    \item \textbf{Initialisation} : $S = \emptyset$. $C = \{e_1, e_2, e_3, e_4, e_5, e_6, e_7\}$.
    \item \textbf{Itération 1 (Sélection de $e_1$)} :
    \begin{itemize}
        \item \textbf{Sélection} : On choisit $e=e_1$ (Utilité 10).
        \item \textbf{Incorporation} : $S \leftarrow \{e_1\}$. Utilité totale = 10.
        \item \textbf{Mise à jour $C$} : $\text{conflict}(\{e_1\}) = \{e_2, e_3, e_5, e_6, e7\}$.
        \item $C \leftarrow C \setminus \{e_2, e_3, e_5, e_6, e7\}$.
        \item Nouveau $C = \{e_4\}$.
    \end{itemize}
    
    \item \textbf{Itération 2 (Gloutonne)} :
    \begin{itemize}
        \item \textbf{Sélection} : Dans $C=\{e_4(6)\}$, $\max_{e \in C} u(e) = u(e_4) = 6$. L'élément choisi est $e=e_4$.
        \item \textbf{Incorporation} : $S \leftarrow \{e_1, e_6\}$. Utilité totale = $10 + 6 = 16$.
        \item \textbf{Mise à jour $C$} : $\text{conflict}(\{e_4\}) = \{e_4\}$.
        \item $C \leftarrow C \setminus \{e_4\}$.
        \item Nouveau $C = \emptyset$.
    \end{itemize}

    \item \textbf{Arrêt} : La boucle \textbf{While} se termine car $C = \emptyset$.
    
    \item \textbf{Résultat final} : La solution gloutonne retournée est $S = \{e_1, e_4\}$, avec une utilité totale de 16.
\end{enumerate}
%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Heuristique d'amélioration appliquée au SPP}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent


\begin{algorithm}[h!]
    \caption{Procédure de Descente Simple}
    \label{alg:simple_descent}
    \begin{algorithmic}[1] % [1] pour la numérotation des lignes
        \Procedure{DescenteSimple}{solution initiale $x \in X$}
            \Repeat
                \State choisir $x' \in N(x)$ \Comment{Sélectionner un voisin $x'$ de $x$}
                \If {$z(x') < z(x)$} \Comment{Si le voisin $x'$ est meilleur (minimisation)}
                    \State $x \leftarrow x'$ \Comment{Déplacer la solution courante vers ce meilleur voisin}
                \EndIf
            \Until {$f(x') \geq f(x), \forall x' \in N(x)$} \Comment{Jusqu'à ce que $x$ soit un minimum local}
            \State \textbf{Retourner} $x$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\begin{itemize}
    \item X : l'espace de toutes les solutions réalisables (l'espace de recherche)
    \item N(x) : le voisinage de la solution courante $x$
    \item x' : une solution voisine candidate, appartenant au voisinage $N(x)$
    \item z(x) : la fonction objectif de la solution $x$
    \item f(x) : la condition d'arrêt qui signifie que la procédure s'arrête lorsque la solution courante $x$ est un optimum local, c'est-à-dire qu'aucune solution voisine $x'$ n'est meilleure que $x$
\end{itemize}

\subsection*{Exemple Didactique de la Descente Simple}

\textbf{Déroulement de l'algorithme (avec $x_{initial} = \{1, 4\}$) :}

\begin{enumerate}
    \item \textbf{Étape 1 : Initialisation.}
    \begin{itemize}
        \item Solution courante : $x = \{1, 4\}$.
        \item Coût courant : $z(x) = c_1 + c_4 = 10 + 6 = 16$.
    \end{itemize}

    \item \textbf{Étape 2 : Exploration (Boucle Repeat 1).}
    \begin{itemize}
        \item Voisinage $N(x)$ (Ajout ou Retrait d'un élément) :
        \begin{itemize}
            \item Retrait : $x'_a = \{1\}$, $z(x'_a)=10$. NON ($10 < 16$).
            \item Retrait : $x'_b = \{4\}$, $z(x'_b)=6$. NON ($6 < 16$).
            \item Ajout : $x'_c = \{1, 4, 5\}$, $z(x'_c)=10+6+9=25$. OUI ($25 > 16$).
        \end{itemize}
        \item Voisin choisi (le meilleur trouvé ou le premier trouvé meilleur) : $x' = \{1, 4, 5\}$.
        \item Mise à jour : $x \leftarrow \{1, 4, 5\}$.
    \end{itemize}

    \item \textbf{Étape 3 : Exploration (Boucle Repeat 2).}
    \begin{itemize}
        \item Solution courante : $x = \{1, 4, 5\}$, $z(x) = 25$.
        \item Voisinage $N(x)$ (Ajout ou Retrait) :
        \begin{itemize}
            \item Retrait : $x'_d = \{4, 5\}$, $z(x'_d)=6+9=15$. NON.
            \item Ajout : $x'_e = \{1, 4, 5, 6\}$, $z(x'_e)=10+6+9+13=38$. OUI ($38 > 25$).
        \end{itemize}
        \item Voisin choisi : $x' = \{1, 4, 5, 6\}$.
        \item Mise à jour : $x \leftarrow \{1, 4, 5, 6\}$.
    \end{itemize}

    \item \textbf{Étape 4 : Exploration (Boucle Repeat 3).}
    \begin{itemize}
        \item Solution courante : $x = \{1, 4, 5, 6\}$, $z(x) = 38$.
        \item Voisinage $N(x)$ (Ajout ou Retrait) :
        \begin{itemize}
            \item Retrait : $x'_f = \{1, 5, 6\}$, $z(x'_f)=10+9+13=32$. NON.
            \item Ajout : $x'_g = \{1, 4, 5, 6, 7\}$, $z(x'_g)=10+6+9+13+11=49$. OUI ($49 > 38$).
        \end{itemize}
        \item Voisin choisi : $x' = \{1, 4, 5, 6, 7\}$.
        \item Mise à jour : $x \leftarrow \{1, 4, 5, 6, 7\}$.
    \end{itemize}
    
    \item \textbf{Étape 5 : Exploration (Boucle Repeat 4).}
    \begin{itemize}
        \item Solution courante : $x = \{1, 4, 5, 6, 7\}$, $z(x) = 49$.
        \item Voisinage $N(x)$ (Retrait d'un élément) :
        \begin{itemize}
            \item Retrait de $1$ : $z=39$. NON.
            \item Retrait de $4$ : $z=43$. NON.
            \item Retrait de $7$ : $z=38$. NON.
        \end{itemize}
        \item \textbf{Condition d'arrêt atteinte :} Aucune solution voisine n'a un coût supérieur à $z(x)=49$.
    \end{itemize}

    \item \textbf{Résultat :} L'algorithme s'arrête en $x=\{1, 4, 5, 6, 7\}$ avec un coût $z(x)=49$. Cette solution est un \textbf{maximum local}.
\end{enumerate}

%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Expérimentation numérique}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
Machine sur laquelle les résultats ont été enregistrés : 

MacMini M4 (ARM) - CPU 10 cœurs

Result E1
\begin{longtable}[c]{| c | c | c | c | c |}
\hline
File & Heuristic & Time (s) & Local Search & Time (s) \\
\hline
pb\_1000rnd0100.dat & 22 & 0.156478 & 40 & 5.488210 \\
pb\_1000rnd0800.dat & 108 & 0.001138 & 108 & 25.506977 \\
pb\_100rnd0500.dat & 533 & 0.000038 & 620 & 0.025510 \\
pb\_100rnd1200.dat & 17 & 0.000039 & 17 & 0.012132 \\
pb\_2000rnd0400.dat & 20 & 0.051748 & 20 & 222.783113 \\
pb\_2000rnd0500.dat & 36 & 0.005408 & 91 & 30.030356 \\
pb\_200rnd0300.dat & 424 & 0.000159 & 662 & 4.381937 \\
pb\_200rnd1800.dat & 12 & 0.000074 & 12 & 0.073140 \\
pb\_500rnd0700.dat & 667 & 0.000266 & 975 & 38.437973 \\
pb\_500rnd1700.dat & 98 & 0.000663 & 137 & 3.493589 \\
\hline
\end{longtable}



%
% -----------------------------------------------------------------------------------------------------------------------------------------------------
%

\vspace{5mm}
\noindent
\fbox{
  \begin{minipage}{0.97 \textwidth}
    \begin{center}
      \vspace{1mm}
        \Large{Discussion}
      \vspace{1mm}
    \end{center}
  \end{minipage}
}
\vspace{2mm}

\noindent
Dans ces exemples, l'utilisation de GLPK n'est pas justifiée car, dans la plupart des cas, sa résolution prend plus de 10 minutes, et obtenir de bonnes solutions n'est pas seulement une question de résultats, mais aussi de temps.
En revanche, mon heuristique trouve une solution beaucoup plus rapidement, mais nous sommes encore un peu loin de l'optimalité. Avec la recherche locale par échange 1-1, nous nous approchons dans un délai acceptable. J'ai choisi cette implémentation pour sa simplicité et, surtout, pour sa priorité donnée au gain de temps.
Ainsi, comparée à GLPK, elle est préférable car au moins, nous avons toujours une solution.

\noindent
Je suppose que l'utilisation de métaheuristiques pourrait être prometteuse , il existe certainement des solutions plus éloignées, difficiles à explorer avec les techniques de voisinage classiques.

\noindent
Dans mon exemple, je n'utilise pas l'algorithme de Glouton traditionnel, qui ne sélectionne pas la valeur maximale dans l'espace des candidats, mais la suivante admissible. La solution initiale importe peu, c'est le chemin d'exploration qui compte pour trouver la solution optimale.

\noindent
Dans ce cas, nous n'avons pas d'aléatoire, une piste d'amélioration pourrait consister à réduire le déterminisme, comme c'était le cas dans GRASP.
